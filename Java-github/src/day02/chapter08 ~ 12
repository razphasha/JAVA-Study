ㅁ chapter08. 클래스 패스와 패키지
	1. 클래스 패스 : 클래스의 경로를 뜻함. 자바 가상머신은 프로그램의 실행과정에서 실행에 필요한 클래스를 찾을 때, 바로 이 클래스 패스를 기준으로 찾게 된다.
	2. 환경 변수 : 다른 프로그램의 실행 능력을 지니는 명령 프롬프트는 환경변수 path를 참조하여, 실행파일의 위치를 탐색하게 된다.
	
	* 클래스 파일이 저장되어 있는 디렉터리 정보를 표시해서 인스턴스를 생성하기 위해 등장한 것이 바로 '패키지'라는 문법적 요소이다.
	ex) orange.area.Circle c1 = new orange.area.Circle(); ----------> orange : 패키지, area : 서브 패키지
	* 패키지의 구조대로 디렉터리가 생성되었다면, 패키지의 선언을 소스파일의 윗부분에 명시해서 컴파일만 하면 된다.
 	ex) package orange.area;
 	
 	3. 이름 없는 패키지 : 별도의 패키지 선언이 존재하지 않는 파일에 정의되어 있는 클래스들은 "이름 없는 패키지"라는 것으로 묶이게 된다고 자바에서는 명시하고 있다.
 	
 	4. import : 해당 import를 선언하고 난 후부터는 다음 두가지 방식으로 생성할 수 있다.
 	ex) import orange.area.Circle;
 		
 		orange.area.Circle c1 = new orange.area.Circle(1.5);
 		Circle c2 = new Circle(2.5);
 	
 ㅁ chapter09. 접근제어 지시자와 정보은닉, 그리고 캡슐화
	1. 정보은닉 : 인스턴스 변수에 private 선언 해서 프로그램에 안전성을 높이는 것.
		- 대부분의 인스턴스 변수는 private로 선언이 된다. 대신 private로 선언된 이 변수의 간접접근을 허용하기 위해 추가적인 메소드를 제공한다. 이러한 유형의 메소드를 'Access 메소드'라 한다.
		ex) 변수이 이름이 XXX이면, XXX의 값을 변경하는 메소드의 이름은 setXXX, 그리고 XXX의 값을 반환하는 메소드의 이름은 getXXX로 정의한다.
	
	2. 접근제어 지시자
		- 접근제어 지시자를 선언하지 않는 경우는 default 선언이라 한다. default로 선언된 인스턴스 변수 및 인스턴스 메소드는 동일 패키지 내에서의 접근을 허용한다.
		- 하나의 소스파일에는 하나의 클래스만 public으로 선언할 수 있다.
		- public 클래스의 이름과 소스파일의 이름은 완전히 일치해야 한다.
	
	3. 캡슐화
		- 관련있는 메소드와 변수를 하나의 클래스 안에 묶는 것
		
ㅁ chapter10. 클래스 변수와 클래스 메소드
	1. static 변수(클래스 변수) : static으로 선언된 변수는 메모리 공간에 하나만 존재하며, 어디서나 접근이 가능한 변수이다. 단 어디서나 접근이 가능 하려면 static 변수도 public으로 선언되어야 한다.
		- static 변수가 초기화되는 시점은 JVM에 의해서 클래스가 메모리 공간에 올라가는 순간이다.
		- 클래스 내부 또는 외부에서 참조의 용도로만 선언된 변수는 static final로 선언한다.
	
	2. static 메소드(클래스 메소드) : static 메소드가 삽입된 클래스의 모든 인스턴스로부터 접근이 가능하다.
		- static 메소드 내에서는 static 변수나 static 메소드가 아닌, 인스턴스 변수나 인스턴스 메소드의 접근이 불가능하다.
		- main 메소드는 인스턴스의 생성과 상관없이 JVM에 의해 호출이 된다.

ㅁ chapter11. 메소드 오버로딩과 String 클래스
	1. 메소드 오버로딩 : 매개변수의 선언형태가 다르면 동일한 메소드를 정의할 수 있다. (= 매개변수의 타입이 다르거나 개수가 다르거나)
		- 반환형이 다른 것은 메소드 오버로딩이 성립 되지 않는다.
		- 생성자도 오버로딩의 대상이 된다.
		
	2. String 클래스
		- 큰따옴표로 문자열을 표현하면, 키워드 new를 이용해서 인스턴스를 생성할 때와 마찬가지로 인스턴스 생성 후에, 생성된 인스턴스의 참조 값이 반환된다.
		- String의 인스턴스에 저장된 문자열은 데이터의 변경이 불가능 하기 때문에 String 클래스의 인스턴스는 상수 형태의 인스턴스이다.
		- 문자열이 동일한 경우에는 하나의 String 인스턴스만 생성해서 공유하도록 한다.
		- 자바는 인스턴스의 생성의 수를 줄이기 위해서 동일한 문자열 데이터로 구성되는 String 인스턴스의 생성을 하나로 제한한다. 그리고 이를 통한 문제의 발생을 막기 위해서 String 인스턴스의
		  데이터 변경은 허용을 하지 않고 있다.
		  
		* java.sun.com : API문서를 볼수 있음.
		
		- public int length() : 문자열 길이 반환
		- public String concat(String str) : 두 문자열의 결합
		- public int compareTo : 두문자열의 비교
		
		- String str1 = "Lemon"+"ade"; 문장은 컴파일러에 의해서 다음과 같이 변환되어 처리된다 ---> String str1 = "Lemon".concat("ade");
		- 문자열의 +연산이 가능한 이유는 자바 컴파일러가 +연산자를 적절한 형태의 메소드 호출문으로 변환하기 때문이다.
		
		- String클래스의 valueOf 메소드 : 전달되는 데이터를 문자열(String 인스턴스)로 변환해서, 해당 인스턴스의 참조 값을 반환하는 static 메소드들이다.
		
	3. StringBuilder & StringBuffer 클래스
		- StringBuilder : 문자열의 저장 및 변경을 위한 메모리 공간을 지니는데, 이 메모리 공간은 그 크기가 자동으로 조절된다는 특징이 있다.
		- StringBuilder - append 메소드 : 전달된 값을, StringBuilder의 인스턴스가 저장하고 있는 문자열 데이터의 끝에 문자의 형태로 추가한다.
		- StringBuilder의 내부에 존재하는 버퍼는 자동으로 크기가 증가하도록 설계되어 있다.
		- StringBuffer는 쓰레드에 안전하지만, StringBuilder는 쓰레드에 안전하지 못하다.

ㅁ chapter12. 콘솔 입력과 출력
	1. System.out.println 메소드와 print 메소드는 문자열이 아닌 인스턴스의 참조 값이 전달되면, 해당 인스턴스의 toString 메소드를 호출하여, 이 때 반환되는 문자열을 출력한다.
	
ㅁ chapter13. 배열
	1. 배열의 참조변수 선언 : int[] ref;
	2. 배열 생성 : int[] ref = new int[5];
	3. 배열의 선언과 동시에 초기화 : int[] arr = new int[3] {1, 2, 3}; / int[] arr = {1, 2, 3};
	4. int[] arr 과 int arr[]는 동일한 의미를 갖는다.
	5. 2차원 배열의 선언 및 초기화 : int[][] arr = { {1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12} };
	* 가로의 길이가 일정하지 않은 배열을 가리켜 'Ragged Array'라고 한다.
	
	6. for-each 문 : 모든 배열 요소의 참조를 위해 사용하는 반복문이다.
		- for(int e : arr)					// arr : 배열의이름 // e : 배열 요소를 지칭하는 변수
			System.out.println(e+" ");	
	